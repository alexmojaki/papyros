(()=>{"use strict";var e,n,t={572:(e,n,t)=>{var r,o=t(375),i=t(29),s=t(155),a="__init_papyros",l="__process_code",c='\nfrom pyodide import to_js, eval_code_async\nfrom js import console\nimport sys\nimport ast\nimport json\nimport html\nimport types\nimport os\nimport micropip\nawait micropip.install(\'friendly_traceback\')\nimport friendly_traceback\nfrom friendly_traceback.core import FriendlyTraceback\n\npapyros = None\n\nclass Papyros():\n    def __init__(self, cb):\n        self.cb = cb\n        self.line = ""\n        self.override_builtins()\n\n    def message(self, data):\n        return self.cb(to_js(data))\n\n    def override_builtins(self):\n        self.override_output()\n        self.override_input()\n        self.override_matplotlib()\n\n    def override_output(self):\n        class OutputWriter:\n            def __init__(self, type, on_write, original):\n                self.encoding = "utf-8"\n                self.type = type\n                self.on_write = on_write\n                self.original = original\n                \n            def write(self, s):\n                if isinstance(s, bytes):\n                    s = s.decode("utf8", "replace")\n                self.on_write(dict(type=self.type, data=s))\n\n            def flush(self):\n                pass # Given data is always immediately written\n\n            def __getattr__(self, item):\n                return getattr(self.original, item)\n\n        on_write = lambda d: self.message(d)\n        sys.stdout = OutputWriter("output", on_write, sys.stdout)\n        sys.stderr = OutputWriter("error", on_write, sys.stderr)\n\n    def readline(self, n=-1, prompt=""):\n        if not self.line:\n            self.line = self.message(dict(type="input", data=prompt)) + "\\n"\n        if n < 0 or n > len(self.line):\n            n = len(self.line)\n        to_return = self.line[0:n]\n        self.line = self.line[n:]\n        return to_return\n\n    def globals(self, filename):\n        mod = types.ModuleType("__main__")\n        mod.__file__ = filename\n        sys.modules["__main__"] = mod\n        return mod.__dict__\n\n    def override_input(self):\n        sys.stdin.readline = self.readline\n        import builtins\n        builtins.input = lambda prompt="": self.readline(prompt=prompt)[:-1] # Remove newline\n\n    def override_matplotlib(self):\n        # workaround from https://github.com/pyodide/pyodide/issues/1518\n        import base64\n        import os\n        \n        from io import BytesIO\n    \n        os.environ[\'MPLBACKEND\'] = \'AGG\'\n        \n        import matplotlib.pyplot\n        def show():\n            buf = BytesIO()\n            matplotlib.pyplot.savefig(buf, format=\'png\')\n            buf.seek(0)\n            # encode to a base64 str\n            img = base64.b64encode(buf.read()).decode(\'utf-8\')\n            matplotlib.pyplot.clf()\n            self.message(dict(type="output", content="img", data=img))\n        \n        matplotlib.pyplot.show = show\n\ndef format_exception(filename, exc):\n    fr = FriendlyTraceback(type(exc), exc, exc.__traceback__)\n    fr.assign_generic()\n    fr.assign_cause()\n    tb = fr.info.get("shortened_traceback", "No traceback")\n    info = fr.info.get("generic", "No information available.")\n    why = fr.info.get("cause", "Unknown cause")\n    what = fr.info.get("message", "No message")\n    user_start = 0\n    tb_lines = tb.split("\\n")\n    while user_start < len(tb_lines) and filename not in tb_lines[user_start]:\n        user_start += 1\n    name = type(exc).__name__\n    user_end = user_start + 1\n    while user_end < len(tb_lines) and name not in tb_lines[user_end]:\n        user_end += 1\n    where = "\\n".join(tb_lines[user_start:user_end]) or "No location"\n    return json.dumps(\n        dict(\n            name=name,\n            traceback=tb,\n            info=info,\n            why=why,\n            where=where,\n            what=what\n        )\n    )\n\ndef '.concat(a,"(cb):\n    global papyros\n    papyros = Papyros(cb)\n\nasync def ").concat(l,'(code, filename="my_code.py"):\n    with open(filename, "w") as f:\n        f.write(code)\n    friendly_traceback.source_cache.cache.add(filename, code)\n    try:\n        await eval_code_async(code, papyros.globals(filename),\n                filename=filename, return_mode="none")\n    except Exception as e:\n        papyros.message(dict(type="error", data=format_exception(filename, e)))\n\n'),p=(r=function(e,n){return r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])},r(e,n)},function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");function t(){this.constructor=e}r(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}),f=function(e,n,t,r){return new(t||(t=Promise))((function(o,i){function s(e){try{l(r.next(e))}catch(e){i(e)}}function a(e){try{l(r.throw(e))}catch(e){i(e)}}function l(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(s,a)}l((r=r.apply(e,n||[])).next())}))},u=function(e,n){var t,r,o,i,s={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(t)throw new TypeError("Generator is already executing.");for(;s;)try{if(t=1,r&&(o=2&i[0]?r.return:i[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,i[1])).done)return o;switch(r=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,r=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!((o=(o=s.trys).length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){s.label=i[1];break}if(6===i[0]&&s.label<o[1]){s.label=o[1],o=i;break}if(o&&s.label<o[2]){s.label=o[2],s.ops.push(i);break}o[2]&&s.ops.pop(),s.trys.pop();continue}i=n.call(e,s)}catch(e){i=[6,e],r=0}finally{t=o=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}};importScripts("https://cdn.jsdelivr.net/pyodide/v0.18.1/full/pyodide.js");var d=function(e){function n(){var n=e.call(this)||this;return n.pyodide={},n.initialized=!1,n}return p(n,e),n.prototype.launch=function(n,t,r){return f(this,void 0,void 0,(function(){var o,i,s=this;return u(this,(function(l){switch(l.label){case 0:return[4,e.prototype.launch.call(this,n,t,r)];case 1:return l.sent(),o=this,[4,loadPyodide({indexURL:"https://cdn.jsdelivr.net/pyodide/v0.18.1/full/",fullStdLib:!1})];case 2:return o.pyodide=l.sent(),[4,this.runCode(c,0)];case 3:return l.sent(),i=function(e){var n="toJs"in e?e.toJs():Object.fromEntries(e);return s.onEvent(n)},this.pyodide.globals.get(a)(i),this.initialized=!0,[2]}}))}))},n.prototype._runCodeInternal=function(e){return f(this,void 0,void 0,(function(){var n;return u(this,(function(t){switch(t.label){case 0:return t.trys.push([0,2,,3]),[4,this.pyodide.loadPackagesFromImports(e)];case 1:return t.sent(),[3,3];case 2:return n=t.sent(),(0,s.V)(s.h.Debug,"Something went wrong while loading imports: ",n),[3,3];case 3:return this.initialized?[4,this.pyodide.globals.get(l)(e)]:[3,5];case 4:return t.sent(),[3,6];case 5:return[2,this.pyodide.runPythonAsync(e)];case 6:return[2]}}))}))},n}(i.z);(0,o.Jj)(new d)}},r={};function o(e){var n=r[e];if(void 0!==n)return n.exports;var i=r[e]={exports:{}};return t[e](i,i.exports,o),i.exports}o.m=t,o.x=()=>{var e=o.O(void 0,[965],(()=>o(572)));return o.O(e)},e=[],o.O=(n,t,r,i)=>{if(!t){var s=1/0;for(p=0;p<e.length;p++){for(var[t,r,i]=e[p],a=!0,l=0;l<t.length;l++)(!1&i||s>=i)&&Object.keys(o.O).every((e=>o.O[e](t[l])))?t.splice(l--,1):(a=!1,i<s&&(s=i));if(a){e.splice(p--,1);var c=r();void 0!==c&&(n=c)}}return n}i=i||0;for(var p=e.length;p>0&&e[p-1][2]>i;p--)e[p]=e[p-1];e[p]=[t,r,i]},o.d=(e,n)=>{for(var t in n)o.o(n,t)&&!o.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},o.f={},o.e=e=>Promise.all(Object.keys(o.f).reduce(((n,t)=>(o.f[t](e,n),n)),[])),o.u=e=>e+".bundle.js",o.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),o.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),(()=>{var e;o.g.importScripts&&(e=o.g.location+"");var n=o.g.document;if(!e&&n&&(n.currentScript&&(e=n.currentScript.src),!e)){var t=n.getElementsByTagName("script");t.length&&(e=t[t.length-1].src)}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),o.p=e})(),(()=>{var e={572:1};o.f.i=(n,t)=>{e[n]||importScripts(o.p+o.u(n))};var n=self.webpackChunkpapyros=self.webpackChunkpapyros||[],t=n.push.bind(n);n.push=n=>{var[r,i,s]=n;for(var a in i)o.o(i,a)&&(o.m[a]=i[a]);for(s&&s(o);r.length;)e[r.pop()]=1;t(n)}})(),n=o.x,o.x=()=>o.e(965).then(n),o.x()})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFZQSxFQUFVUSxRQUFRLE9BQVEsSUFBSUEsUUFBUSxRQUFTLElBQUlBLFFBQVEsWUFBYSxLQUNwRnhELEVBQW9CeUQsRUFBSVQsRyxTQ1h4QixJQUFJVSxFQUFrQixDQUNyQixJQUFLLEdBZ0JOMUQsRUFBb0IrQixFQUFFZCxFQUFJLENBQUNnQixFQUFTSSxLQUUvQnFCLEVBQWdCekIsSUFFbEI1RCxjQUFjMkIsRUFBb0J5RCxFQUFJekQsRUFBb0JzQyxFQUFFTCxLQUsvRCxJQUFJMEIsRUFBcUJDLEtBQTBCLG9CQUFJQSxLQUEwQixxQkFBSyxHQUNsRkMsRUFBNkJGLEVBQW1CRyxLQUFLQyxLQUFLSixHQUM5REEsRUFBbUJHLEtBdkJDNUUsSUFDbkIsSUFBSzBCLEVBQVVvRCxFQUFhQyxHQUFXL0UsRUFDdkMsSUFBSSxJQUFJZSxLQUFZK0QsRUFDaEJoRSxFQUFvQjRCLEVBQUVvQyxFQUFhL0QsS0FDckNELEVBQW9CTyxFQUFFTixHQUFZK0QsRUFBWS9ELElBSWhELElBREdnRSxHQUFTQSxFQUFRakUsR0FDZFksRUFBU00sUUFDZHdDLEVBQWdCOUMsRUFBU3NELE9BQVMsRUFDbkNMLEVBQTJCM0UsSyxHVm5CeEJqQixFQUFPK0IsRUFBb0JRLEVBQy9CUixFQUFvQlEsRUFBSSxJQUNoQlIsRUFBb0JnQyxFQUFFLEtBQUttQyxLQUFLbEcsR1dEZCtCLEVBQW9CUSxLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGFweXJvcy93ZWJwYWNrL3J1bnRpbWUvY2h1bmsgbG9hZGVkIiwid2VicGFjazovL3BhcHlyb3Mvd2VicGFjay9ydW50aW1lL3N0YXJ0dXAgY2h1bmsgZGVwZW5kZW5jaWVzIiwid2VicGFjazovL3BhcHlyb3MvLi9zcmMvd29ya2Vycy9weXRob24vaW5pdC5weS50cyIsIndlYnBhY2s6Ly9wYXB5cm9zLy4vc3JjL3dvcmtlcnMvcHl0aG9uL1B5dGhvbldvcmtlci53b3JrZXIudHMiLCJ3ZWJwYWNrOi8vcGFweXJvcy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9wYXB5cm9zL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9wYXB5cm9zL3dlYnBhY2svcnVudGltZS9lbnN1cmUgY2h1bmsiLCJ3ZWJwYWNrOi8vcGFweXJvcy93ZWJwYWNrL3J1bnRpbWUvZ2V0IGphdmFzY3JpcHQgY2h1bmsgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vcGFweXJvcy93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3BhcHlyb3Mvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9wYXB5cm9zL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL3BhcHlyb3Mvd2VicGFjay9ydW50aW1lL2ltcG9ydFNjcmlwdHMgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly9wYXB5cm9zL3dlYnBhY2svc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGVmZXJyZWQgPSBbXTtcbl9fd2VicGFja19yZXF1aXJlX18uTyA9IChyZXN1bHQsIGNodW5rSWRzLCBmbiwgcHJpb3JpdHkpID0+IHtcblx0aWYoY2h1bmtJZHMpIHtcblx0XHRwcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cdFx0Zm9yKHZhciBpID0gZGVmZXJyZWQubGVuZ3RoOyBpID4gMCAmJiBkZWZlcnJlZFtpIC0gMV1bMl0gPiBwcmlvcml0eTsgaS0tKSBkZWZlcnJlZFtpXSA9IGRlZmVycmVkW2kgLSAxXTtcblx0XHRkZWZlcnJlZFtpXSA9IFtjaHVua0lkcywgZm4sIHByaW9yaXR5XTtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIG5vdEZ1bGZpbGxlZCA9IEluZmluaXR5O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGRlZmVycmVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIFtjaHVua0lkcywgZm4sIHByaW9yaXR5XSA9IGRlZmVycmVkW2ldO1xuXHRcdHZhciBmdWxmaWxsZWQgPSB0cnVlO1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgY2h1bmtJZHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdGlmICgocHJpb3JpdHkgJiAxID09PSAwIHx8IG5vdEZ1bGZpbGxlZCA+PSBwcmlvcml0eSkgJiYgT2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5PKS5ldmVyeSgoa2V5KSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXy5PW2tleV0oY2h1bmtJZHNbal0pKSkpIHtcblx0XHRcdFx0Y2h1bmtJZHMuc3BsaWNlKGotLSwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmdWxmaWxsZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYocHJpb3JpdHkgPCBub3RGdWxmaWxsZWQpIG5vdEZ1bGZpbGxlZCA9IHByaW9yaXR5O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihmdWxmaWxsZWQpIHtcblx0XHRcdGRlZmVycmVkLnNwbGljZShpLS0sIDEpXG5cdFx0XHR2YXIgciA9IGZuKCk7XG5cdFx0XHRpZiAociAhPT0gdW5kZWZpbmVkKSByZXN1bHQgPSByO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufTsiLCJ2YXIgbmV4dCA9IF9fd2VicGFja19yZXF1aXJlX18ueDtcbl9fd2VicGFja19yZXF1aXJlX18ueCA9ICgpID0+IHtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZSg5NjUpLnRoZW4obmV4dCk7XG59OyIsImV4cG9ydCBjb25zdCBJTklUSUFMSVpFX1BZVEhPTl9CQUNLRU5EID0gXCJfX2luaXRfcGFweXJvc1wiO1xuZXhwb3J0IGNvbnN0IFBST0NFU1NfUFlUSE9OX0NPREUgPSBcIl9fcHJvY2Vzc19jb2RlXCI7XG5leHBvcnQgY29uc3QgSU5JVElBTElaQVRJT05fQ09ERSA9XG4gICAgYFxuZnJvbSBweW9kaWRlIGltcG9ydCB0b19qcywgZXZhbF9jb2RlX2FzeW5jXG5mcm9tIGpzIGltcG9ydCBjb25zb2xlXG5pbXBvcnQgc3lzXG5pbXBvcnQgYXN0XG5pbXBvcnQganNvblxuaW1wb3J0IGh0bWxcbmltcG9ydCB0eXBlc1xuaW1wb3J0IG9zXG5pbXBvcnQgbWljcm9waXBcbmF3YWl0IG1pY3JvcGlwLmluc3RhbGwoJ2ZyaWVuZGx5X3RyYWNlYmFjaycpXG5pbXBvcnQgZnJpZW5kbHlfdHJhY2ViYWNrXG5mcm9tIGZyaWVuZGx5X3RyYWNlYmFjay5jb3JlIGltcG9ydCBGcmllbmRseVRyYWNlYmFja1xuXG5wYXB5cm9zID0gTm9uZVxuXG5jbGFzcyBQYXB5cm9zKCk6XG4gICAgZGVmIF9faW5pdF9fKHNlbGYsIGNiKTpcbiAgICAgICAgc2VsZi5jYiA9IGNiXG4gICAgICAgIHNlbGYubGluZSA9IFwiXCJcbiAgICAgICAgc2VsZi5vdmVycmlkZV9idWlsdGlucygpXG5cbiAgICBkZWYgbWVzc2FnZShzZWxmLCBkYXRhKTpcbiAgICAgICAgcmV0dXJuIHNlbGYuY2IodG9fanMoZGF0YSkpXG5cbiAgICBkZWYgb3ZlcnJpZGVfYnVpbHRpbnMoc2VsZik6XG4gICAgICAgIHNlbGYub3ZlcnJpZGVfb3V0cHV0KClcbiAgICAgICAgc2VsZi5vdmVycmlkZV9pbnB1dCgpXG4gICAgICAgIHNlbGYub3ZlcnJpZGVfbWF0cGxvdGxpYigpXG5cbiAgICBkZWYgb3ZlcnJpZGVfb3V0cHV0KHNlbGYpOlxuICAgICAgICBjbGFzcyBPdXRwdXRXcml0ZXI6XG4gICAgICAgICAgICBkZWYgX19pbml0X18oc2VsZiwgdHlwZSwgb25fd3JpdGUsIG9yaWdpbmFsKTpcbiAgICAgICAgICAgICAgICBzZWxmLmVuY29kaW5nID0gXCJ1dGYtOFwiXG4gICAgICAgICAgICAgICAgc2VsZi50eXBlID0gdHlwZVxuICAgICAgICAgICAgICAgIHNlbGYub25fd3JpdGUgPSBvbl93cml0ZVxuICAgICAgICAgICAgICAgIHNlbGYub3JpZ2luYWwgPSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgZGVmIHdyaXRlKHNlbGYsIHMpOlxuICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UocywgYnl0ZXMpOlxuICAgICAgICAgICAgICAgICAgICBzID0gcy5kZWNvZGUoXCJ1dGY4XCIsIFwicmVwbGFjZVwiKVxuICAgICAgICAgICAgICAgIHNlbGYub25fd3JpdGUoZGljdCh0eXBlPXNlbGYudHlwZSwgZGF0YT1zKSlcblxuICAgICAgICAgICAgZGVmIGZsdXNoKHNlbGYpOlxuICAgICAgICAgICAgICAgIHBhc3MgIyBHaXZlbiBkYXRhIGlzIGFsd2F5cyBpbW1lZGlhdGVseSB3cml0dGVuXG5cbiAgICAgICAgICAgIGRlZiBfX2dldGF0dHJfXyhzZWxmLCBpdGVtKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0YXR0cihzZWxmLm9yaWdpbmFsLCBpdGVtKVxuXG4gICAgICAgIG9uX3dyaXRlID0gbGFtYmRhIGQ6IHNlbGYubWVzc2FnZShkKVxuICAgICAgICBzeXMuc3Rkb3V0ID0gT3V0cHV0V3JpdGVyKFwib3V0cHV0XCIsIG9uX3dyaXRlLCBzeXMuc3Rkb3V0KVxuICAgICAgICBzeXMuc3RkZXJyID0gT3V0cHV0V3JpdGVyKFwiZXJyb3JcIiwgb25fd3JpdGUsIHN5cy5zdGRlcnIpXG5cbiAgICBkZWYgcmVhZGxpbmUoc2VsZiwgbj0tMSwgcHJvbXB0PVwiXCIpOlxuICAgICAgICBpZiBub3Qgc2VsZi5saW5lOlxuICAgICAgICAgICAgc2VsZi5saW5lID0gc2VsZi5tZXNzYWdlKGRpY3QodHlwZT1cImlucHV0XCIsIGRhdGE9cHJvbXB0KSkgKyBcIlxcXFxuXCJcbiAgICAgICAgaWYgbiA8IDAgb3IgbiA+IGxlbihzZWxmLmxpbmUpOlxuICAgICAgICAgICAgbiA9IGxlbihzZWxmLmxpbmUpXG4gICAgICAgIHRvX3JldHVybiA9IHNlbGYubGluZVswOm5dXG4gICAgICAgIHNlbGYubGluZSA9IHNlbGYubGluZVtuOl1cbiAgICAgICAgcmV0dXJuIHRvX3JldHVyblxuXG4gICAgZGVmIGdsb2JhbHMoc2VsZiwgZmlsZW5hbWUpOlxuICAgICAgICBtb2QgPSB0eXBlcy5Nb2R1bGVUeXBlKFwiX19tYWluX19cIilcbiAgICAgICAgbW9kLl9fZmlsZV9fID0gZmlsZW5hbWVcbiAgICAgICAgc3lzLm1vZHVsZXNbXCJfX21haW5fX1wiXSA9IG1vZFxuICAgICAgICByZXR1cm4gbW9kLl9fZGljdF9fXG5cbiAgICBkZWYgb3ZlcnJpZGVfaW5wdXQoc2VsZik6XG4gICAgICAgIHN5cy5zdGRpbi5yZWFkbGluZSA9IHNlbGYucmVhZGxpbmVcbiAgICAgICAgaW1wb3J0IGJ1aWx0aW5zXG4gICAgICAgIGJ1aWx0aW5zLmlucHV0ID0gbGFtYmRhIHByb21wdD1cIlwiOiBzZWxmLnJlYWRsaW5lKHByb21wdD1wcm9tcHQpWzotMV0gIyBSZW1vdmUgbmV3bGluZVxuXG4gICAgZGVmIG92ZXJyaWRlX21hdHBsb3RsaWIoc2VsZik6XG4gICAgICAgICMgd29ya2Fyb3VuZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9weW9kaWRlL3B5b2RpZGUvaXNzdWVzLzE1MThcbiAgICAgICAgaW1wb3J0IGJhc2U2NFxuICAgICAgICBpbXBvcnQgb3NcbiAgICAgICAgXG4gICAgICAgIGZyb20gaW8gaW1wb3J0IEJ5dGVzSU9cbiAgICBcbiAgICAgICAgb3MuZW52aXJvblsnTVBMQkFDS0VORCddID0gJ0FHRydcbiAgICAgICAgXG4gICAgICAgIGltcG9ydCBtYXRwbG90bGliLnB5cGxvdFxuICAgICAgICBkZWYgc2hvdygpOlxuICAgICAgICAgICAgYnVmID0gQnl0ZXNJTygpXG4gICAgICAgICAgICBtYXRwbG90bGliLnB5cGxvdC5zYXZlZmlnKGJ1ZiwgZm9ybWF0PSdwbmcnKVxuICAgICAgICAgICAgYnVmLnNlZWsoMClcbiAgICAgICAgICAgICMgZW5jb2RlIHRvIGEgYmFzZTY0IHN0clxuICAgICAgICAgICAgaW1nID0gYmFzZTY0LmI2NGVuY29kZShidWYucmVhZCgpKS5kZWNvZGUoJ3V0Zi04JylcbiAgICAgICAgICAgIG1hdHBsb3RsaWIucHlwbG90LmNsZigpXG4gICAgICAgICAgICBzZWxmLm1lc3NhZ2UoZGljdCh0eXBlPVwib3V0cHV0XCIsIGNvbnRlbnQ9XCJpbWdcIiwgZGF0YT1pbWcpKVxuICAgICAgICBcbiAgICAgICAgbWF0cGxvdGxpYi5weXBsb3Quc2hvdyA9IHNob3dcblxuZGVmIGZvcm1hdF9leGNlcHRpb24oZmlsZW5hbWUsIGV4Yyk6XG4gICAgZnIgPSBGcmllbmRseVRyYWNlYmFjayh0eXBlKGV4YyksIGV4YywgZXhjLl9fdHJhY2ViYWNrX18pXG4gICAgZnIuYXNzaWduX2dlbmVyaWMoKVxuICAgIGZyLmFzc2lnbl9jYXVzZSgpXG4gICAgdGIgPSBmci5pbmZvLmdldChcInNob3J0ZW5lZF90cmFjZWJhY2tcIiwgXCJObyB0cmFjZWJhY2tcIilcbiAgICBpbmZvID0gZnIuaW5mby5nZXQoXCJnZW5lcmljXCIsIFwiTm8gaW5mb3JtYXRpb24gYXZhaWxhYmxlLlwiKVxuICAgIHdoeSA9IGZyLmluZm8uZ2V0KFwiY2F1c2VcIiwgXCJVbmtub3duIGNhdXNlXCIpXG4gICAgd2hhdCA9IGZyLmluZm8uZ2V0KFwibWVzc2FnZVwiLCBcIk5vIG1lc3NhZ2VcIilcbiAgICB1c2VyX3N0YXJ0ID0gMFxuICAgIHRiX2xpbmVzID0gdGIuc3BsaXQoXCJcXFxcblwiKVxuICAgIHdoaWxlIHVzZXJfc3RhcnQgPCBsZW4odGJfbGluZXMpIGFuZCBmaWxlbmFtZSBub3QgaW4gdGJfbGluZXNbdXNlcl9zdGFydF06XG4gICAgICAgIHVzZXJfc3RhcnQgKz0gMVxuICAgIG5hbWUgPSB0eXBlKGV4YykuX19uYW1lX19cbiAgICB1c2VyX2VuZCA9IHVzZXJfc3RhcnQgKyAxXG4gICAgd2hpbGUgdXNlcl9lbmQgPCBsZW4odGJfbGluZXMpIGFuZCBuYW1lIG5vdCBpbiB0Yl9saW5lc1t1c2VyX2VuZF06XG4gICAgICAgIHVzZXJfZW5kICs9IDFcbiAgICB3aGVyZSA9IFwiXFxcXG5cIi5qb2luKHRiX2xpbmVzW3VzZXJfc3RhcnQ6dXNlcl9lbmRdKSBvciBcIk5vIGxvY2F0aW9uXCJcbiAgICByZXR1cm4ganNvbi5kdW1wcyhcbiAgICAgICAgZGljdChcbiAgICAgICAgICAgIG5hbWU9bmFtZSxcbiAgICAgICAgICAgIHRyYWNlYmFjaz10YixcbiAgICAgICAgICAgIGluZm89aW5mbyxcbiAgICAgICAgICAgIHdoeT13aHksXG4gICAgICAgICAgICB3aGVyZT13aGVyZSxcbiAgICAgICAgICAgIHdoYXQ9d2hhdFxuICAgICAgICApXG4gICAgKVxuXG5kZWYgJHtJTklUSUFMSVpFX1BZVEhPTl9CQUNLRU5EfShjYik6XG4gICAgZ2xvYmFsIHBhcHlyb3NcbiAgICBwYXB5cm9zID0gUGFweXJvcyhjYilcblxuYXN5bmMgZGVmICR7UFJPQ0VTU19QWVRIT05fQ09ERX0oY29kZSwgZmlsZW5hbWU9XCJteV9jb2RlLnB5XCIpOlxuICAgIHdpdGggb3BlbihmaWxlbmFtZSwgXCJ3XCIpIGFzIGY6XG4gICAgICAgIGYud3JpdGUoY29kZSlcbiAgICBmcmllbmRseV90cmFjZWJhY2suc291cmNlX2NhY2hlLmNhY2hlLmFkZChmaWxlbmFtZSwgY29kZSlcbiAgICB0cnk6XG4gICAgICAgIGF3YWl0IGV2YWxfY29kZV9hc3luYyhjb2RlLCBwYXB5cm9zLmdsb2JhbHMoZmlsZW5hbWUpLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lPWZpbGVuYW1lLCByZXR1cm5fbW9kZT1cIm5vbmVcIilcbiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6XG4gICAgICAgIHBhcHlyb3MubWVzc2FnZShkaWN0KHR5cGU9XCJlcnJvclwiLCBkYXRhPWZvcm1hdF9leGNlcHRpb24oZmlsZW5hbWUsIGUpKSlcblxuYDtcbiIsImltcG9ydCB7IGV4cG9zZSB9IGZyb20gXCJjb21saW5rXCI7XG5pbXBvcnQgeyBCYWNrZW5kIH0gZnJvbSBcIi4uLy4uL0JhY2tlbmRcIjtcbmltcG9ydCB7IFBhcHlyb3NFdmVudCB9IGZyb20gXCIuLi8uLi9QYXB5cm9zRXZlbnRcIjtcbmltcG9ydCB7IExvZ1R5cGUsIHBhcHlyb3NMb2cgfSBmcm9tIFwiLi4vLi4vdXRpbC9Mb2dnaW5nXCI7XG5pbXBvcnQgeyBJTklUSUFMSVpBVElPTl9DT0RFLCBJTklUSUFMSVpFX1BZVEhPTl9CQUNLRU5ELCBQUk9DRVNTX1BZVEhPTl9DT0RFIH0gZnJvbSBcIi4vaW5pdC5weVwiO1xuXG5pbnRlcmZhY2UgUHlvZGlkZSB7XG4gICAgcnVuUHl0aG9uOiAoY29kZTogc3RyaW5nLCBnbG9iYWxzPzogYW55KSA9PiBhbnk7XG4gICAgcnVuUHl0aG9uQXN5bmM6IChjb2RlOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gICAgbG9hZFBhY2thZ2VzRnJvbUltcG9ydHM6IChjb2RlOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gICAgZ2xvYmFsczogTWFwPHN0cmluZywgYW55Pjtcbn1cbmRlY2xhcmUgZnVuY3Rpb24gaW1wb3J0U2NyaXB0cyguLi51cmxzOiBzdHJpbmdbXSk6IHZvaWQ7XG5kZWNsYXJlIGZ1bmN0aW9uIGxvYWRQeW9kaWRlKGFyZ3M6IHsgaW5kZXhVUkw6IHN0cmluZzsgZnVsbFN0ZExpYjogYm9vbGVhbiB9KTogUHJvbWlzZTxQeW9kaWRlPjtcblxuaW1wb3J0U2NyaXB0cyhcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9weW9kaWRlL3YwLjE4LjEvZnVsbC9weW9kaWRlLmpzXCIpO1xuXG5cbmNsYXNzIFB5dGhvbldvcmtlciBleHRlbmRzIEJhY2tlbmQge1xuICAgIHB5b2RpZGU6IFB5b2RpZGU7XG4gICAgaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5weW9kaWRlID0ge30gYXMgUHlvZGlkZTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIG92ZXJyaWRlIGFzeW5jIGxhdW5jaChvbkV2ZW50OiAoZTogUGFweXJvc0V2ZW50KSA9PiB2b2lkLFxuICAgICAgICBpbnB1dFRleHRBcnJheT86IFVpbnQ4QXJyYXksIGlucHV0TWV0YURhdGE/OiBJbnQzMkFycmF5KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHN1cGVyLmxhdW5jaChvbkV2ZW50LCBpbnB1dFRleHRBcnJheSwgaW5wdXRNZXRhRGF0YSk7XG4gICAgICAgIHRoaXMucHlvZGlkZSA9IGF3YWl0IGxvYWRQeW9kaWRlKHtcbiAgICAgICAgICAgIGluZGV4VVJMOiBcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9weW9kaWRlL3YwLjE4LjEvZnVsbC9cIixcbiAgICAgICAgICAgIGZ1bGxTdGRMaWI6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLnJ1bkNvZGUoSU5JVElBTElaQVRJT05fQ09ERSwgMCk7XG4gICAgICAgIC8vIFB5dGhvbiBjYWxscyBvdXIgZnVuY3Rpb24gd2l0aCBhIGRpY3QsIHdoaWNoIG11c3QgYmUgY29udmVydGVkIHRvIGEgUGFweXJvc0V2ZW50XG4gICAgICAgIGNvbnN0IGV2ZW50Q2FsbGJhY2sgPSAoZGF0YTogYW55KTogdm9pZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBqc0V2ZW50OiBQYXB5cm9zRXZlbnQgPSBcInRvSnNcIiBpbiBkYXRhID8gZGF0YS50b0pzKCkgOiBPYmplY3QuZnJvbUVudHJpZXMoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbkV2ZW50KGpzRXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnB5b2RpZGUuZ2xvYmFscy5nZXQoSU5JVElBTElaRV9QWVRIT05fQkFDS0VORCkoZXZlbnRDYWxsYmFjayk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIG92ZXJyaWRlIGFzeW5jIF9ydW5Db2RlSW50ZXJuYWwoY29kZTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHlvZGlkZS5sb2FkUGFja2FnZXNGcm9tSW1wb3J0cyhjb2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcGFweXJvc0xvZyhMb2dUeXBlLkRlYnVnLCBcIlNvbWV0aGluZyB3ZW50IHdyb25nIHdoaWxlIGxvYWRpbmcgaW1wb3J0czogXCIsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB5b2RpZGUuZ2xvYmFscy5nZXQoUFJPQ0VTU19QWVRIT05fQ09ERSkoY29kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5weW9kaWRlLnJ1blB5dGhvbkFzeW5jKGNvZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvc2UobmV3IFB5dGhvbldvcmtlcigpKTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuLy8gdGhlIHN0YXJ0dXAgZnVuY3Rpb25cbl9fd2VicGFja19yZXF1aXJlX18ueCA9ICgpID0+IHtcblx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5cdC8vIFRoaXMgZW50cnkgbW9kdWxlIGRlcGVuZHMgb24gb3RoZXIgbG9hZGVkIGNodW5rcyBhbmQgZXhlY3V0aW9uIG5lZWQgdG8gYmUgZGVsYXllZFxuXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFs5NjVdLCAoKSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXyg1NzIpKSlcblx0X193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18uTyhfX3dlYnBhY2tfZXhwb3J0c19fKTtcblx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG59O1xuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmYgPSB7fTtcbi8vIFRoaXMgZmlsZSBjb250YWlucyBvbmx5IHRoZSBlbnRyeSBjaHVuay5cbi8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5lID0gKGNodW5rSWQpID0+IHtcblx0cmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uZikucmVkdWNlKChwcm9taXNlcywga2V5KSA9PiB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mW2tleV0oY2h1bmtJZCwgcHJvbWlzZXMpO1xuXHRcdHJldHVybiBwcm9taXNlcztcblx0fSwgW10pKTtcbn07IiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYXN5bmMgY2h1bmtzIGFuZCBzaWJsaW5nIGNodW5rcyBmb3IgdGhlIGVudHJ5cG9pbnRcbl9fd2VicGFja19yZXF1aXJlX18udSA9IChjaHVua0lkKSA9PiB7XG5cdC8vIHJldHVybiB1cmwgZm9yIGZpbGVuYW1lcyBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRyZXR1cm4gXCJcIiArIGNodW5rSWQgKyBcIi5idW5kbGUuanNcIjtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwidmFyIHNjcmlwdFVybDtcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmcuaW1wb3J0U2NyaXB0cykgc2NyaXB0VXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmxvY2F0aW9uICsgXCJcIjtcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5kb2N1bWVudDtcbmlmICghc2NyaXB0VXJsICYmIGRvY3VtZW50KSB7XG5cdGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KVxuXHRcdHNjcmlwdFVybCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjXG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkgc2NyaXB0VXJsID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLnNyY1xuXHR9XG59XG4vLyBXaGVuIHN1cHBvcnRpbmcgYnJvd3NlcnMgd2hlcmUgYW4gYXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dC5wdWJsaWNQYXRoIG1hbnVhbGx5IHZpYSBjb25maWd1cmF0aW9uXG4vLyBvciBwYXNzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikgYW5kIHNldCB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gdmFyaWFibGUgZnJvbSB5b3VyIGNvZGUgdG8gdXNlIHlvdXIgb3duIGxvZ2ljLlxuaWYgKCFzY3JpcHRVcmwpIHRocm93IG5ldyBFcnJvcihcIkF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuc2NyaXB0VXJsID0gc2NyaXB0VXJsLnJlcGxhY2UoLyMuKiQvLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sIFwiL1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18ucCA9IHNjcmlwdFVybDsiLCIvLyBubyBiYXNlVVJJXG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgY2h1bmtzXG4vLyBcIjFcIiBtZWFucyBcImFscmVhZHkgbG9hZGVkXCJcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdDU3MjogMVxufTtcblxuLy8gaW1wb3J0U2NyaXB0cyBjaHVuayBsb2FkaW5nXG52YXIgaW5zdGFsbENodW5rID0gKGRhdGEpID0+IHtcblx0dmFyIFtjaHVua0lkcywgbW9yZU1vZHVsZXMsIHJ1bnRpbWVdID0gZGF0YTtcblx0Zm9yKHZhciBtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm1bbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuXHRcdH1cblx0fVxuXHRpZihydW50aW1lKSBydW50aW1lKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHR3aGlsZShjaHVua0lkcy5sZW5ndGgpXG5cdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRzLnBvcCgpXSA9IDE7XG5cdHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKGRhdGEpO1xufTtcbl9fd2VicGFja19yZXF1aXJlX18uZi5pID0gKGNodW5rSWQsIHByb21pc2VzKSA9PiB7XG5cdC8vIFwiMVwiIGlzIHRoZSBzaWduYWwgZm9yIFwiYWxyZWFkeSBsb2FkZWRcIlxuXHRpZighaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0aWYodHJ1ZSkgeyAvLyBhbGwgY2h1bmtzIGhhdmUgSlNcblx0XHRcdGltcG9ydFNjcmlwdHMoX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy51KGNodW5rSWQpKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSBzZWxmW1wid2VicGFja0NodW5rcGFweXJvc1wiXSA9IHNlbGZbXCJ3ZWJwYWNrQ2h1bmtwYXB5cm9zXCJdIHx8IFtdO1xudmFyIHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uID0gY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2guYmluZChjaHVua0xvYWRpbmdHbG9iYWwpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSBpbnN0YWxsQ2h1bms7XG5cbi8vIG5vIEhNUlxuXG4vLyBubyBITVIgbWFuaWZlc3QiLCIvLyBydW4gc3RhcnR1cFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fLngoKTtcbiJdLCJuYW1lcyI6WyJkZWZlcnJlZCIsIm5leHQiLCJJTklUSUFMSVpFX1BZVEhPTl9CQUNLRU5EIiwiUFJPQ0VTU19QWVRIT05fQ09ERSIsIklOSVRJQUxJWkFUSU9OX0NPREUiLCJpbXBvcnRTY3JpcHRzIiwicHlvZGlkZSIsImluaXRpYWxpemVkIiwibGF1bmNoIiwib25FdmVudCIsImlucHV0VGV4dEFycmF5IiwiaW5wdXRNZXRhRGF0YSIsInRoaXMiLCJsb2FkUHlvZGlkZSIsImluZGV4VVJMIiwiZnVsbFN0ZExpYiIsInJ1bkNvZGUiLCJldmVudENhbGxiYWNrIiwiZGF0YSIsImpzRXZlbnQiLCJ0b0pzIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJnbG9iYWxzIiwiZ2V0IiwiX3J1bkNvZGVJbnRlcm5hbCIsImNvZGUiLCJsb2FkUGFja2FnZXNGcm9tSW1wb3J0cyIsInJ1blB5dGhvbkFzeW5jIiwiQmFja2VuZCIsIlB5dGhvbldvcmtlciIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsInVuZGVmaW5lZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwibSIsIngiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiTyIsInJlc3VsdCIsImNodW5rSWRzIiwiZm4iLCJwcmlvcml0eSIsIm5vdEZ1bGZpbGxlZCIsIkluZmluaXR5IiwiaSIsImxlbmd0aCIsImZ1bGZpbGxlZCIsImoiLCJrZXlzIiwiZXZlcnkiLCJrZXkiLCJzcGxpY2UiLCJyIiwiZCIsImRlZmluaXRpb24iLCJvIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZiIsImUiLCJjaHVua0lkIiwiUHJvbWlzZSIsImFsbCIsInJlZHVjZSIsInByb21pc2VzIiwidSIsImciLCJnbG9iYWxUaGlzIiwiRnVuY3Rpb24iLCJ3aW5kb3ciLCJvYmoiLCJwcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwic2NyaXB0VXJsIiwibG9jYXRpb24iLCJkb2N1bWVudCIsImN1cnJlbnRTY3JpcHQiLCJzcmMiLCJzY3JpcHRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJFcnJvciIsInJlcGxhY2UiLCJwIiwiaW5zdGFsbGVkQ2h1bmtzIiwiY2h1bmtMb2FkaW5nR2xvYmFsIiwic2VsZiIsInBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uIiwicHVzaCIsImJpbmQiLCJtb3JlTW9kdWxlcyIsInJ1bnRpbWUiLCJwb3AiLCJ0aGVuIl0sInNvdXJjZVJvb3QiOiIifQ==